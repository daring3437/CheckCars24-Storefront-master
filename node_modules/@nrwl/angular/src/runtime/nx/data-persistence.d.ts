import { Type } from '@angular/core';
import { ActivatedRouteSnapshot } from '@angular/router';
import { Actions } from '@ngrx/effects';
import { Action, Store, ActionCreator } from '@ngrx/store';
import { Observable } from 'rxjs';
/**
 * See {@link DataPersistence.pessimisticUpdate} for more information.
 */
import * as ɵngcc0 from '@angular/core';
export interface PessimisticUpdateOpts<T, A> {
    run(a: A, state?: T): Observable<Action> | Action | void;
    onError(a: A, e: any): Observable<any> | any;
}
/**
 * See {@link DataPersistence.pessimisticUpdate} for more information.
 */
export interface OptimisticUpdateOpts<T, A> {
    run(a: A, state?: T): Observable<Action> | Action | void;
    undoAction(a: A, e: any): Observable<Action> | Action;
}
/**
 * See {@link DataPersistence.fetch} for more information.
 */
export interface FetchOpts<T, A> {
    id?(a: A, state?: T): any;
    run(a: A, state?: T): Observable<Action> | Action | void;
    onError?(a: A, e: any): Observable<any> | any;
}
/**
 * See {@link DataPersistence.navigation} for more information.
 */
export interface HandleNavigationOpts<T> {
    run(a: ActivatedRouteSnapshot, state?: T): Observable<Action> | Action | void;
    onError?(a: ActivatedRouteSnapshot, e: any): Observable<any> | any;
}
export declare type ActionOrActionWithState<T, A> = A | [A, T];
export declare type ActionStateStream<T, A> = Observable<ActionOrActionWithState<T, A>>;
export declare function pessimisticUpdate<T, A extends Action>(opts: PessimisticUpdateOpts<T, A>): (source: ActionStateStream<T, A>) => Observable<Action>;
export declare function optimisticUpdate<T, A extends Action>(opts: OptimisticUpdateOpts<T, A>): (source: ActionStateStream<T, A>) => Observable<Action>;
export declare function fetch<T, A extends Action>(opts: FetchOpts<T, A>): (source: ActionStateStream<T, A>) => Observable<Action>;
export declare function navigation<T, A extends Action>(component: Type<any>, opts: HandleNavigationOpts<T>): (source: ActionStateStream<T, A>) => Observable<Action>;
/**
 * @whatItDoes Provides convenience methods for implementing common operations of persisting data.
 */
export declare class DataPersistence<T> {
    store: Store<T>;
    actions: Actions;
    constructor(store: Store<T>, actions: Actions);
    /**
     *
     * @whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    pessimisticUpdate<A extends Action = Action>(actionType: string | ActionCreator, opts: PessimisticUpdateOpts<T, A>): Observable<any>;
    /**
     *
     * @whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    optimisticUpdate<A extends Action = Action>(actionType: string | ActionCreator, opts: OptimisticUpdateOpts<T, A>): Observable<any>;
    /**
     *
     * @whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     */
    fetch<A extends Action = Action>(actionType: string | ActionCreator, opts: FetchOpts<T, A>): Observable<any>;
    /**
     * @whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     */
    navigation(component: Type<any>, opts: HandleNavigationOpts<T>): Observable<any>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DataPersistence<any>, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<DataPersistence<any>>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5kLnRzIiwic291cmNlcyI6WyJkYXRhLXBlcnNpc3RlbmNlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEFjdGlvbnMgfSBmcm9tICdAbmdyeC9lZmZlY3RzJztcbmltcG9ydCB7IEFjdGlvbiwgU3RvcmUsIEFjdGlvbkNyZWF0b3IgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLnBlc3NpbWlzdGljVXBkYXRlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT4ge1xuICAgIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICAgIG9uRXJyb3IoYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5wZXNzaW1pc3RpY1VwZGF0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT4ge1xuICAgIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICAgIHVuZG9BY3Rpb24oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uO1xufVxuLyoqXG4gKiBTZWUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZS5mZXRjaH0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hPcHRzPFQsIEE+IHtcbiAgICBpZD8oYTogQSwgc3RhdGU/OiBUKTogYW55O1xuICAgIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICAgIG9uRXJyb3I/KGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UubmF2aWdhdGlvbn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlTmF2aWdhdGlvbk9wdHM8VD4ge1xuICAgIHJ1bihhOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICAgIG9uRXJyb3I/KGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cbmV4cG9ydCBkZWNsYXJlIHR5cGUgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4gPSBBIHwgW0EsIFRdO1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPiA9IE9ic2VydmFibGU8QWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gcGVzc2ltaXN0aWNVcGRhdGU8VCwgQSBleHRlbmRzIEFjdGlvbj4ob3B0czogUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQsIEE+KTogKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pID0+IE9ic2VydmFibGU8QWN0aW9uPjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG9wdGltaXN0aWNVcGRhdGU8VCwgQSBleHRlbmRzIEFjdGlvbj4ob3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT4pOiAoc291cmNlOiBBY3Rpb25TdGF0ZVN0cmVhbTxULCBBPikgPT4gT2JzZXJ2YWJsZTxBY3Rpb24+O1xuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gZmV0Y2g8VCwgQSBleHRlbmRzIEFjdGlvbj4ob3B0czogRmV0Y2hPcHRzPFQsIEE+KTogKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pID0+IE9ic2VydmFibGU8QWN0aW9uPjtcbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIG5hdmlnYXRpb248VCwgQSBleHRlbmRzIEFjdGlvbj4oY29tcG9uZW50OiBUeXBlPGFueT4sIG9wdHM6IEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+KTogKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pID0+IE9ic2VydmFibGU8QWN0aW9uPjtcbi8qKlxuICogQHdoYXRJdERvZXMgUHJvdmlkZXMgY29udmVuaWVuY2UgbWV0aG9kcyBmb3IgaW1wbGVtZW50aW5nIGNvbW1vbiBvcGVyYXRpb25zIG9mIHBlcnNpc3RpbmcgZGF0YS5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRGF0YVBlcnNpc3RlbmNlPFQ+IHtcbiAgICBzdG9yZTogU3RvcmU8VD47XG4gICAgYWN0aW9uczogQWN0aW9ucztcbiAgICBjb25zdHJ1Y3RvcihzdG9yZTogU3RvcmU8VD4sIGFjdGlvbnM6IEFjdGlvbnMpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBwZXNzaW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgc2VydmVyIGZpcnN0KS5cbiAgICAgKlxuICAgICAqIFVwZGF0ZSB0aGUgc2VydmVyIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIGBwZXNzaW1pc3RpY1VwZGF0ZWAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgICAqICAgQEVmZmVjdCgpIHVwZGF0ZVRvZG8gPSB0aGlzLnMucGVzc2ltaXN0aWNVcGRhdGU8VXBkYXRlVG9kbz4oJ1VQREFURV9UT0RPJywge1xuICAgICAqICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb24gYW5kIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZVxuICAgICAqICAgICBydW4oYSwgc3RhdGUpIHtcbiAgICAgKiAgICAgICAvLyB1cGRhdGUgdGhlIGJhY2tlbmQgZmlyc3QsIGFuZCB0aGVuIGRpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IHdpbGxcbiAgICAgKiAgICAgICAvLyB1cGRhdGUgdGhlIGNsaWVudCBzaWRlXG4gICAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZChzdGF0ZS51c2VyLCBhLnBheWxvYWQpLm1hcCh1cGRhdGVkID0+ICh7XG4gICAgICogICAgICAgICB0eXBlOiAnVE9ET19VUERBVEVEJyxcbiAgICAgKiAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZWRcbiAgICAgKiAgICAgICB9KSk7XG4gICAgICogICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgb25FcnJvcihhLCBlOiBhbnkpIHtcbiAgICAgKiAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVuZG8gdGhlIGNoYW5nZXMgb24gdGhlIGNsaWVudCBzaWRlLlxuICAgICAqICAgICAgIC8vIHdlIGNhbiBkaXNwYXRjaCBhbiBlcnJvciwgb3Igc2ltcGx5IGxvZyB0aGUgZXJyb3IgaGVyZSBhbmQgcmV0dXJuIGBudWxsYFxuICAgICAqICAgICAgIHJldHVybiBudWxsO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gICAgICogb2YgdGhlIGVmZmVjdCB0byBmYWxzZSwgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgICAqICAgQEVmZmVjdCh7ZGlzcGF0Y2g6IGZhbHNlfSlcbiAgICAgKiAgIHVwZGF0ZVRvZG87IC8vLi4uXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHBlc3NpbWlzdGljVXBkYXRlPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KGFjdGlvblR5cGU6IHN0cmluZyB8IEFjdGlvbkNyZWF0b3IsIG9wdHM6IFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPik6IE9ic2VydmFibGU8YW55PjtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgb3B0aW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgY2xpZW50IGZpcnN0KS5cbiAgICAgKlxuICAgICAqIGBvcHRpbWlzdGljVXBkYXRlYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMtLWl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zXG4gICAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBgb3B0aW1pc3RpY1VwZGF0ZWAgaXMgZGlmZmVyZW50IGZyb20gYHBlc3NpbWlzdGljVXBkYXRlYC4gSW4gY2FzZSBvZiBhIGZhaWx1cmUsIHdoZW4gdXNpbmcgYG9wdGltaXN0aWNVcGRhdGVgLFxuICAgICAqIHRoZSBkZXZlbG9wZXIgYWxyZWFkeSB1cGRhdGVkIHRoZSBzdGF0ZSBsb2NhbGx5LCBzbyB0aGUgZGV2ZWxvcGVyIG11c3QgcHJvdmlkZSBhbiB1bmRvIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBlcnJvciBoYW5kbGluZyBtdXN0IGJlIGRvbmUgaW4gdGhlIGNhbGxiYWNrLCBvciBieSBtZWFucyBvZiB0aGUgdW5kbyBhY3Rpb24uXG4gICAgICpcbiAgICAgKiAjIyBFeGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAgICogICBARWZmZWN0KCkgdXBkYXRlVG9kbyA9IHRoaXMucy5vcHRpbWlzdGljVXBkYXRlPFVwZGF0ZVRvZG8+KCdVUERBVEVfVE9ETycsIHtcbiAgICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICAgKiAgICAgcnVuOiAoYSwgc3RhdGUpID0+IHtcbiAgICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCk7XG4gICAgICogICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgdW5kb0FjdGlvbjogKGEsIGU6IGFueSkgPT4ge1xuICAgICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgICAqICAgICAgIHJldHVybiAoe1xuICAgICAqICAgICAgICAgdHlwZTogJ1VORE9fVVBEQVRFX1RPRE8nLFxuICAgICAqICAgICAgICAgcGF5bG9hZDogYVxuICAgICAqICAgICAgIH0pO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgaWYgeW91IGRvbid0IHJldHVybiBhIG5ldyBhY3Rpb24gZnJvbSB0aGUgcnVuIGNhbGxiYWNrLCB5b3UgbXVzdCBzZXQgdGhlIGRpc3BhdGNoIHByb3BlcnR5XG4gICAgICogb2YgdGhlIGVmZmVjdCB0byBmYWxzZSwgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgICAqICAgQEVmZmVjdCh7ZGlzcGF0Y2g6IGZhbHNlfSlcbiAgICAgKiAgIHVwZGF0ZVRvZG87IC8vLi4uXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG9wdGltaXN0aWNVcGRhdGU8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oYWN0aW9uVHlwZTogc3RyaW5nIHwgQWN0aW9uQ3JlYXRvciwgb3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT4pOiBPYnNlcnZhYmxlPGFueT47XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcuXG4gICAgICpcbiAgICAgKiBEYXRhIGZldGNoaW5nIGltcGxlbWVudGVkIG5haXZlbHkgc3VmZmVycyBmcm9tIHJhY2UgY29uZGl0aW9ucyBhbmQgcG9vciBlcnJvciBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIGBmZXRjaGAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgICAqIGFuZCBmb3JjZXMgdGhlIGRldmVsb3BlciB0byBoYW5kbGUgZXJyb3JzLlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvcyA9IHRoaXMucy5mZXRjaDxHZXRUb2Rvcz4oJ0dFVF9UT0RPUycsIHtcbiAgICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICAgKiAgICAgcnVuOiAoYSwgc3RhdGUpID0+IHtcbiAgICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCkubWFwKHIgPT4gKHtcbiAgICAgKiAgICAgICAgIHR5cGU6ICdUT0RPUycsXG4gICAgICogICAgICAgICBwYXlsb2FkOiByXG4gICAgICogICAgICAgfSk7XG4gICAgICogICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgb25FcnJvcjogKGEsIGU6IGFueSkgPT4ge1xuICAgICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGNvcnJlY3QsIGJ1dCBiZWNhdXNlIGl0IHNldCB0aGUgY29uY3VycmVuY3kgdG8gMSwgaXQgbWF5IG5vdCBiZSBwZXJmb3JtYW50LlxuICAgICAqXG4gICAgICogVG8gZml4IHRoYXQsIHlvdSBjYW4gcHJvdmlkZSB0aGUgYGlkYCBmdW5jdGlvbiwgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBJbmplY3RhYmxlKClcbiAgICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAgICogICBARWZmZWN0KCkgbG9hZFRvZG8gPSB0aGlzLnMuZmV0Y2g8R2V0VG9kbz4oJ0dFVF9UT0RPJywge1xuICAgICAqICAgICBpZDogKGEsIHN0YXRlKSA9PiB7XG4gICAgICogICAgICAgcmV0dXJuIGEucGF5bG9hZC5pZDtcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAgICogICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZChzdGF0ZS51c2VyLCBhLnBheWxvYWQpLm1hcChyID0+ICh7XG4gICAgICogICAgICAgICB0eXBlOiAnVE9ETycsXG4gICAgICogICAgICAgICBwYXlsb2FkOiByXG4gICAgICogICAgICAgfSk7XG4gICAgICogICAgIH0sXG4gICAgICpcbiAgICAgKiAgICAgb25FcnJvcjogKGEsIGU6IGFueSkgPT4ge1xuICAgICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgICAqICAgICAgIHJldHVybiBudWxsO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKlxuICAgICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaXRoIHRoaXMgc2V0dXAsIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHdpbGwgcnVuIGNvbmN1cnJlbnRseSB3aXRoIHRoZSByZXF1ZXN0cyBmb3IgVG9kbyAyLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24sIGlmIERhdGFQZXJzaXN0ZW5jZSBub3RpY2VzIHRoYXQgdGhlcmUgYXJlIG11bHRpcGxlIHJlcXVlc3RzIGZvciBUb2RvIDEgc2NoZWR1bGVkLFxuICAgICAqIGl0IHdpbGwgb25seSBydW4gdGhlIGxhc3Qgb25lLlxuICAgICAqL1xuICAgIGZldGNoPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KGFjdGlvblR5cGU6IHN0cmluZyB8IEFjdGlvbkNyZWF0b3IsIG9wdHM6IEZldGNoT3B0czxULCBBPik6IE9ic2VydmFibGU8YW55PjtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBIYW5kbGVzIGRhdGEgZmV0Y2hpbmcgYXMgcGFydCBvZiByb3V0ZXIgbmF2aWdhdGlvbi5cbiAgICAgKlxuICAgICAqIERhdGEgZmV0Y2hpbmcgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICAgICAqXG4gICAgICogYG5hdmlnYXRpb25gIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy5cbiAgICAgKlxuICAgICAqIEl0IGNoZWNrcyBpZiBhbiBhY3RpdmF0ZWQgcm91dGVyIHN0YXRlIGNvbnRhaW5zIHRoZSBwYXNzZWQgaW4gY29tcG9uZW50IHR5cGUsIGFuZCwgaWYgaXQgZG9lcywgcnVucyB0aGUgYHJ1bmBcbiAgICAgKiBjYWxsYmFjay4gSXQgcHJvdmlkZXMgdGhlIGFjdGl2YXRlZCBzbmFwc2hvdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbXBvbmVudCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUuIEFuZCBpdCBvbmx5IHJ1bnNcbiAgICAgKiB0aGUgbGFzdCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgICAqICAgQEVmZmVjdCgpIGxvYWRUb2RvID0gdGhpcy5zLm5hdmlnYXRpb24oVG9kb0NvbXBvbmVudCwge1xuICAgICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZmV0Y2hUb2RvKGEucGFyYW1zWydpZCddKS5tYXAodG9kbyA9PiAoe1xuICAgICAqICAgICAgICAgdHlwZTogJ1RPRE9fTE9BREVEJyxcbiAgICAgKiAgICAgICAgIHBheWxvYWQ6IHRvZG9cbiAgICAgKiAgICAgICB9KSk7XG4gICAgICogICAgIH0sXG4gICAgICogICAgIG9uRXJyb3I6IChhLCBlOiBhbnkpID0+IHtcbiAgICAgKiAgICAgICAvLyB3ZSBjYW4gbG9nIGFuZCBlcnJvciBoZXJlIGFuZCByZXR1cm4gbnVsbFxuICAgICAqICAgICAgIC8vIHdlIGNhbiBhbHNvIG5hdmlnYXRlIGJhY2tcbiAgICAgKiAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHM6IERhdGFQZXJzaXN0ZW5jZTxUb2Rvc1N0YXRlPiwgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBuYXZpZ2F0aW9uKGNvbXBvbmVudDogVHlwZTxhbnk+LCBvcHRzOiBIYW5kbGVOYXZpZ2F0aW9uT3B0czxUPik6IE9ic2VydmFibGU8YW55Pjtcbn1cbiJdfQ==